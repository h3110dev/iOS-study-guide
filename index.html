<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive iOS Interview Study Guide</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!--
        Application Structure Plan: The application now defaults to the "Study Plan" section as the home page, allowing immediate setup of a personalized schedule. A persistent sidebar enables main topic navigation, and a tab-based interface manages sub-topics within the main content area. This two-level structure prevents overwhelming the user and facilitates focused study. Interactive checklists allow users to track progress, visually represented by dynamic donut charts. Crucially, each non-study-plan topic page now integrates its specific study status (Upcoming, In Progress, Past Due) based on the globally set start date, providing contextual awareness of the schedule. This gamified and actionable approach enhances user engagement and progress tracking.
        Visualization & Content Choices:
        - Report Info: Hierarchical list of iOS interview topics. -> Goal: Organize and track study progress. -> Viz/Presentation: A main sidebar navigation controls visibility of content sections. Each section has its own sub-navigation (tabs) for drilling down. -> Interaction: Users click navigation elements to switch views. Checkboxes next to each topic allow users to mark them as "studied". -> Justification: This interactive structure breaks down the vast amount of information into digestible chunks, making it less intimidating and easier to navigate.
        - Report Info: User's study progress. -> Goal: Motivate and provide visual feedback. -> Viz/Presentation: Donut chart. -> Interaction: The chart dynamically updates as users check/uncheck items in the corresponding section. -> Justification: A donut chart is a visually appealing and space-efficient way to show percentage completion, which is more engaging than a simple text counter. Library: Chart.js (Canvas).
        - Report Info: Proposed study schedule for all topics. -> Goal: Provide a structured learning path and estimated duration. -> Viz/Presentation: A dynamic list/table grouped by week, displayed prominently on the home page and as a status on individual topic pages. -> Interaction: User inputs a start date, then clicks a button to generate the plan. The status on topic pages updates automatically based on this plan. -> Justification: This transforms the static syllabus into a personalized, time-bound study guide, enhancing its utility for interview preparation and providing real-time feedback on progress against the schedule.
        - Report Info: Need for dynamic explanations and practice questions. -> Goal: Enhance learning and self-assessment. -> Viz/Presentation: Buttons next to each sub-topic item. -> Interaction: Clicking a button reveals pre-defined explanations or questions. -> Justification: Provides immediate, contextual support and practice directly within the app, making the study experience more interactive and effective.
        CONFIRMATION: NO SVG graphics used. NO Mermaid JS used.
    -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #F8F7F4;
            color: #3D3D3D;
        }
        .chart-container {
            position: relative;
            width: 100%; /* Occupy full parent width */
            max-width: 200px; /* Max-width for the chart container */
            margin-left: auto;
            margin-right: auto;
            height: 160px; /* Base height */
            max-height: 200px; /* Max height */
        }
        @media (min-width: 768px) {
            .chart-container {
                max-width: 250px; /* Slightly larger on medium screens */
                height: 180px;
            }
        }
        @media (min-width: 1024px) {
            .chart-container {
                max-width: 300px; /* Even larger on large screens */
                height: 200px;
            }
        }
        .sidebar-link {
            transition: all 0.2s ease-in-out;
        }
        .sidebar-link.active, .sidebar-link:hover {
            background-color: #E7E5E0;
            color: #2a665c;
            transform: translateX(4px);
        }
        .tab-link {
            white-space: nowrap;
        }
        .tab-link.active {
            border-color: #2a665c;
            color: #2a665c;
            font-weight: 600;
        }
        .content-panel, .sub-content-panel {
            display: none;
        }
        .content-panel.active, .sub-content-panel.active {
            display: block;
        }
        .checklist-item {
            transition: color 0.3s;
            display: flex;
            align-items: flex-start;
            flex-wrap: wrap;
        }
        .checklist-item input[type="checkbox"] {
            margin-top: 0.25rem;
        }
        .checklist-item label {
            flex: 1;
            margin-right: 1rem;
        }
        .checklist-item input[type="checkbox"]:checked + label {
            color: #888;
            text-decoration: line-through;
        }
        .info-toggle-btn {
            background-color: #d6e9e6;
            color: #2a665c;
            font-weight: 600;
            padding: 0.25rem 0.75rem;
            border-radius: 0.375rem;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            transition: background-color 0.2s ease-in-out;
        }
        .info-toggle-btn:hover {
            background-color: #c3e0db;
        }
        .info-content {
            border-left: 3px solid #2a665c;
            background-color: #f0f8f7;
            padding: 1rem;
            margin-top: 0.5rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            color: #4a4a4a;
        }
        .study-plan-topic-link {
            color: #2a665c;
            text-decoration: underline;
            cursor: pointer;
            transition: color 0.2s ease-in-out;
        }
        .study-plan-topic-link:hover {
            color: #1a4f47;
        }
    </style>
</head>
<body class="antialiased">

    <div class="flex flex-col md:flex-row min-h-screen">
        <aside id="sidebar" class="bg-[#ECEAE5] p-4 md:p-6 border-r border-gray-300 flex-shrink-0 transition-all duration-300 ease-in-out w-full md:w-80">
            <div class="flex justify-between items-center mb-2">
                <h1 class="text-2xl font-bold text-[#2a665c] sidebar-text-item">iOS Interview Prep</h1>
                <button id="sidebar-toggle" class="p-2 rounded-md hover:bg-gray-200 text-gray-700">
                    <span class="text-xl">‚ù∞</span>
                </button>
            </div>
            <p class="text-sm text-gray-600 mb-8 sidebar-text-item">An interactive guide to master key topics.</p>
            <nav id="main-nav" class="space-y-2">
            </nav>
        </aside>

        <main id="main-content" class="flex-1 p-4 md:p-10 overflow-y-auto transition-all duration-300 ease-in-out">
        </main>
    </div>

    <script>
        // Global variable to store calculated week dates
        let globalStudyPlanDates = {};
        let currentStudyStartDate = null; // Will store the Date object of the selected start date
        let allChecklistStatuses = {}; // Stores completion status of individual checklist items

        // UPDATED and more comprehensive study data based on the new syllabus
        const studyData = [
            {
                id: 'study-plan',
                title: 'Study Plan',
                description: 'Welcome to your personalized iOS Interview Study Guide! This interactive web application is designed to help you prepare for iOS technical interviews by providing a comprehensive, structured curriculum and a dynamic study planner. Set your preferred start date below, and let\'s build your ideal study journey together!',
                isStudyPlan: true,
                subTopics: []
            },
            {
                id: 'swift-deep-dive',
                title: 'I. Swift Language Deep Dive',
                cleanTitle: 'Swift Language Deep Dive',
                description: 'A thorough understanding of the Swift language is the cornerstone of any iOS developer\'s skillset. This section covers memory management, type systems, concurrency models, and advanced language features.',
                subTopics: [
                    {
                        id: 'swift-memory', title: 'Memory & Types', durationHours: 6, suggestedWeek: 1, content: [
                            { item: 'Automatic Reference Counting (ARC): strong, weak, and unowned references.', explanation: 'ARC automatically frees up memory used by class instances when they are no longer needed. `strong` is the default reference type that keeps an instance alive. `weak` is an optional reference that doesn\'t keep an instance alive and becomes `nil` when the instance is deallocated. `unowned` is a non-optional reference that also doesn\'t keep an instance alive, but you must be certain the instance will not be deallocated while the reference exists.', question: 'Explain a scenario where a retain cycle can occur with closures. How would you use a capture list with `weak` or `unowned` to break this cycle?' },
                            { item: 'Value Types (struct, enum) vs. Reference Types (class) and copy-on-write.', explanation: 'Value types are copied when assigned or passed, creating independent instances. Reference types share a single instance. This fundamentally affects how data is mutated and passed around. Copy-on-write (CoW) is an optimization where a value type shares its underlying data until it is modified, at which point a unique copy is made.', question: 'When would you choose a `struct` over a `class`? Provide an example where the choice significantly impacts your app\'s behavior or performance.' },
                            { item: 'Optionals: Safe unwrapping (if let, guard let), optional chaining, and nil-coalescing.', explanation: 'Optionals handle the presence or absence of a value. Safe unwrapping with `if let` or `guard let` conditionally binds the value to a new constant. Optional chaining (`?`) allows calling properties or methods on an optional that might be `nil`. The nil-coalescing operator (`??`) provides a default value for a `nil` optional.', question: 'Why should you avoid force unwrapping (`!`) in production code? Describe a situation where using the `map` or `flatMap` functions on an Optional can be more concise than using `if let`.' }
                        ]
                    },
                    {
                        id: 'swift-features', title: 'Language Features', durationHours: 7, suggestedWeek: 1, content: [
                            { item: 'Closures: Capture lists, escaping and non-escaping closures.', explanation: 'Closures are self-contained blocks of functionality. They can "capture" constants and variables from their surrounding context. `@escaping` closures can be executed after the function they were passed into returns, whereas non-escaping closures cannot.', question: 'What is the purpose of an `@autoclosure`? Provide a practical example of its use.' },
                            { item: 'Protocols: Protocol-Oriented Programming (POP), extensions, and associated types.', explanation: 'POP is a design paradigm that favors composing functionality through protocols. Protocol extensions can provide default implementations for methods, and `associatedtype` allows for creating generic protocols.', question: 'How can you use protocol extensions to add functionality to types you don\'t own, like `String` or `Array`? What are the limitations of this approach?' },
                            { item: 'Generics: Type parameters, generic constraints, and opaque types (`some Protocol`).', explanation: 'Generics allow you to write flexible, reusable code that works with any type, subject to specified constraints. Opaque types (`some Protocol`) hide the concrete return type of a function, providing abstraction while guaranteeing a specific protocol conformance.', question: 'Explain the difference between using a generic type parameter (`<T: Equatable>`) and using `some Equatable` as a return type.' },
                            { item: 'Error Handling: do-catch, try, try?, try!, and the Result type.', explanation: 'Swift\'s formal error handling model allows functions to `throw` errors, which are then handled in a `do-catch` block. `try?` converts an error into an optional `nil`, while `try!` asserts that no error will occur. The `Result` type explicitly represents either a success with a value or a failure with an error.', question: 'When would you use the `Result` type for an asynchronous operation instead of a traditional completion handler with `(Data?, Error?)` parameters?' }
                        ]
                    },
                    {
                        id: 'swift-concurrency', title: 'Concurrency', durationHours: 8, suggestedWeek: 2, content: [
                            { item: 'GCD: DispatchQueues (serial, concurrent), DispatchGroups, Semaphores.', explanation: 'Grand Central Dispatch (GCD) is a low-level API for managing concurrent operations. `DispatchQueue` manages the execution of tasks. `DispatchGroup` allows you to track the completion of a group of tasks. `DispatchSemaphore` controls access to a shared resource by multiple threads.', question: 'You need to download three images concurrently and then update the UI only after all three are downloaded. How would you use a `DispatchGroup` to achieve this?' },
                            { item: '`Operation` & `OperationQueue`: Dependencies and subclassing.', explanation: '`Operation` is a high-level abstraction over GCD that allows for more complex behaviors like setting dependencies between operations, canceling, and observing state changes. You can subclass `Operation` for reusable, complex tasks.', question: 'Describe a scenario where `OperationQueue` is a better choice than using GCD directly. How would you make an `Operation` dependent on another?' },
                            { item: 'Swift Concurrency: `async/await`, `Task`, `TaskGroup`.', explanation: 'Modern Swift Concurrency provides a safer and more readable way to write asynchronous code. `async/await` allows you to write async code that looks sequential. A `Task` is a unit of async work. A `TaskGroup` allows for dynamically creating a group of concurrent child tasks.', question: 'How does Structured Concurrency in Swift help prevent task leakage compared to older concurrency models like GCD?' },
                            { item: '`Actors` for isolating mutable state and `@MainActor` for UI updates.', explanation: 'An `Actor` is a reference type that protects its mutable state from concurrent access, preventing data races. `@MainActor` is a global actor that ensures code runs on the main thread, which is essential for safe UI updates.', question: 'Explain how an `Actor` prevents data races. What happens when you try to access a property or call a method on an actor from outside of it?' }
                        ]
                    },
                     {
                        id: 'swift-advanced-concepts', title: 'Advanced Topics', durationHours: 5, suggestedWeek: 2, content: [
                            { item: 'Property Wrappers: Encapsulating property logic (e.g., @Published).', explanation: 'Property wrappers add a layer of separation between code that manages how a property is stored and the code that defines a property. They are reusable structures that encapsulate custom logic for property getting and setting. Examples include SwiftUI\'s `@State` or Combine\'s `@Published`.', question: 'Design a simple `@UserDefault` property wrapper that automatically reads and writes a property\'s value to `UserDefaults`.' },
                            { item: 'Access Control: open, public, internal, fileprivate, private.', explanation: 'Access control restricts access to parts of your code from code in other source files and modules. `private` is the most restrictive, `fileprivate` restricts to the current file, `internal` is the default, `public` allows access from other modules, and `open` (for classes) allows subclassing from other modules.', question: 'What is the difference between `public` and `open`? When would you use `fileprivate`?' },
                            { item: 'Key-Value Coding (KVC) and Key-Value Observing (KVO).', explanation: 'KVC is a mechanism for accessing an object\'s properties indirectly, using strings to identify properties. KVO allows an object to observe changes to another object\'s properties. These are Objective-C patterns, but still available and sometimes used in Swift, especially with `NSObject` subclasses.', question: 'While modern Swift prefers other patterns (like Combine or `didSet`), describe a scenario where KVO might still be useful in an iOS project.' }
                        ]
                    }
                ]
            },
            {
                id: 'ios-core-concepts',
                title: 'II. iOS Frameworks & Core Concepts',
                cleanTitle: 'iOS Frameworks & Concepts',
                description: 'Mastering the core frameworks is essential for building any iOS application. This section covers UI, data management, and networking fundamentals.',
                subTopics: [
                    {
                        id: 'ios-ui', title: 'UI & Layout', durationHours: 9, suggestedWeek: 3, content: [
                            { item: 'App and UIViewController lifecycles.', explanation: 'The app lifecycle includes states like `active`, `inactive`, and `background`. The `UIViewController` lifecycle includes methods like `viewDidLoad`, `viewWillAppear`, `viewDidLayoutSubviews`, and `viewDidDisappear`, which are critical for setting up UI, loading data, and cleaning up resources.', question: 'In which `UIViewController` lifecycle method would you perform initial data loading from a network? What about view-related setup that depends on the view\'s final size?' },
                            { item: '`UITableView` and `UICollectionView`: Cell reuse, prefetching, and custom layouts.', explanation: 'These are fundamental for displaying lists of data. Cell reuse (`dequeueReusableCell`) is critical for performance. Prefetching allows for loading data for cells before they come on screen. Custom layouts can be achieved with `UICollectionViewLayout` subclasses.', question: 'Explain the purpose of `prepareForReuse()` on a `UITableViewCell`. What kind of cleanup would you typically do there?' },
                            { item: 'Auto Layout: Constraints, priorities, intrinsic content size, and debugging.', explanation: 'Auto Layout is a constraint-based system for defining adaptive user interfaces. `intrinsicContentSize` is a view\'s natural size. Priorities resolve conflicts between constraints. Debugging often involves inspecting the view hierarchy and identifying conflicting or ambiguous constraints.', question: 'You have two labels side-by-side. How would you use Content Hugging and Compression Resistance priorities to ensure one label grows to fill space while the other stays at its intrinsic width?' },
                             { item: '`UIGestureRecognizer` and creating custom UI components.', explanation: '`UIGestureRecognizer` subclasses (e.g., `UITapGestureRecognizer`, `UIPanGestureRecognizer`) are used to detect user interactions. Custom components are typically created by subclassing `UIView` or `UIControl` and can involve custom drawing with `draw(_:)` and handling touches.', question: 'Outline the steps to create a simple custom circular switch control by subclassing `UIControl`. What properties and methods would be essential?' }
                        ]
                    },
                    {
                        id: 'ios-data', title: 'Data & Networking', durationHours: 7, suggestedWeek: 4, content: [
                            { item: 'Data Persistence: `UserDefaults`, `Core Data`, `Realm`, `Codable`.', explanation: '`UserDefaults` is for simple key-value data. `Codable` is for encoding/decoding data to formats like JSON. `Core Data` is Apple\'s powerful framework for managing an object graph and persistence. `Realm` is a popular third-party alternative.', question: 'What is a `NSManagedObjectContext` in Core Data and why is it important for thread safety?' },
                            { item: 'Offline storage and data syncing strategies.', explanation: 'A robust app should work offline. This involves caching data locally (e.g., in Core Data or Realm) and having a strategy to sync with a server when connectivity is restored. Strategies can include pull-to-refresh, background fetch, or push-triggered updates.', question: 'Design a basic strategy for an app feature that allows a user to "like" a post while offline. How would you queue this action and sync it later?' },
                            { item: '`URLSession`: Data, download, and upload tasks.', explanation: '`URLSession` is the primary API for networking in iOS. It can be used for simple data tasks (fetching JSON), as well as background download and upload tasks for large files.', question: 'How do you handle network errors, such as a timeout or no internet connection, when using `URLSession`? What is the role of the `URLSessionDelegate`?' },
                            { item: 'REST APIs, JSON, and secure communication (HTTPS, Keychain).', explanation: 'Most iOS apps communicate with a server via a RESTful API, typically using JSON as the data format. All communication should use HTTPS to be secure. For storing sensitive data like auth tokens on the device, the `Keychain` provides encrypted storage.', question: 'What is the purpose of SSL Pinning? What are its benefits and drawbacks?' }
                        ]
                    }
                ]
            },
            {
                id: 'design-patterns',
                title: 'III. Architecture & Design Patterns',
                cleanTitle: 'Architecture & Design Patterns',
                description: 'Good architecture is the foundation of a maintainable and scalable app. This section explores common architectural patterns and fundamental software design patterns.',
                subTopics: [
                    {
                        id: 'patterns-architectural', title: 'Architectural Patterns', durationHours: 6, suggestedWeek: 5, content: [
                            { item: 'MVC (Model-View-Controller) and the "Massive View Controller" problem.', explanation: 'MVC separates concerns into Model (data), View (UI), and Controller (logic). However, in iOS, the Controller often becomes a dumping ground for all logic, leading to the "Massive View Controller" problem, which makes code hard to test and maintain.', question: 'What are some specific strategies you can use to slim down a Massive View Controller? Name at least three types of logic you would move out and where you would move them to.' },
                            { item: 'MVVM (Model-View-ViewModel) and its benefits over MVC.', explanation: 'MVVM introduces a ViewModel, which sits between the View/Controller and the Model. The ViewModel prepares data for the view, handles presentation logic, and can be easily tested without any UI. This improves separation of concerns and testability compared to MVC.', question: 'How does data binding work in an MVVM architecture? Explain with an example using either Combine or closures.' },
                            { item: 'VIPER (View, Interactor, Presenter, Entity, Router) for large applications.', explanation: 'VIPER is a more rigid architecture that further separates responsibilities. `Interactor` handles business logic, `Presenter` handles presentation logic, and `Router` handles navigation. This strict separation is beneficial for very large teams and complex applications but comes with more boilerplate code.', question: 'What is the single responsibility of the `Interactor` in VIPER? How does it communicate its results back to the `Presenter`?' }
                        ]
                    },
                    {
                        id: 'patterns-foundational', title: 'Foundational Patterns', durationHours: 5, suggestedWeek: 5, content: [
                            { item: 'Singleton: Use cases and drawbacks.', explanation: 'The Singleton pattern ensures that only one instance of a class exists and provides a global point of access to it. It\'s often used for shared resources like a network manager or user session. However, it can make dependency management and testing difficult.', question: 'Why is the Singleton pattern often called an "anti-pattern"? What alternative could you use to provide a shared instance while improving testability?' },
                            { item: 'Delegate Pattern: Purpose and implementation.', explanation: 'The Delegate pattern allows one object to send messages to another object when a specific event occurs, enabling custom behavior. It defines a one-to-one communication channel. It\'s heavily used in UIKit (e.g., `UITableViewDelegate`).', question: 'What is the difference between the Delegate pattern and the Observer pattern (using NotificationCenter)? When would you choose one over the other?' },
                            { item: 'Observer Pattern: `NotificationCenter` and Key-Value Observing (KVO).', explanation: 'The Observer pattern defines a one-to-many dependency between objects. When one object changes state, all of its dependents are notified automatically. `NotificationCenter` broadcasts notifications to any interested observers, while KVO observes changes to specific properties of `NSObject` subclasses.', question: 'How do you ensure an observer removes itself correctly when using `NotificationCenter` to avoid memory leaks or crashes?' },
                            { item: 'Factory and Facade Patterns.', explanation: 'The Factory pattern provides an interface for creating objects in a superclass, but lets subclasses alter the type of objects that will be created. The Facade pattern provides a simplified, higher-level interface to a complex subsystem of classes.', question: 'Provide an example of where you might use the Facade pattern in an iOS app to simplify interactions with a complex framework like Core Data.' }
                        ]
                    }
                ]
            },
            {
                id: 'performance-tooling',
                title: 'IV. Performance, Security & Tooling',
                cleanTitle: 'Performance, Security & Tooling',
                description: 'A professional iOS developer must be proficient in optimizing performance, ensuring security, and using the available tools for testing and deployment.',
                subTopics: [
                    {
                        id: 'tooling-performance', title: 'Performance & Notifications', durationHours: 6, suggestedWeek: 6, content: [
                            { item: 'Performance optimization techniques for responsiveness and load times.', explanation: 'This includes optimizing table/collection view scrolling by implementing cell reuse correctly, doing expensive work on background threads, and optimizing app launch time by deferring non-essential work.', question: 'Your app\'s launch time is slow. What steps would you take using Instruments to diagnose the bottleneck?' },
                            { item: 'Debugging with Instruments (Time Profiler, Allocations, Leaks).', explanation: 'Instruments is a powerful suite of tools. Time Profiler finds CPU bottlenecks. Allocations tracks memory usage and helps find abandoned memory. Leaks specifically finds retain cycles.', question: 'How does the "Leaks" instrument detect a memory leak? What does a "cycle" in the object graph mean?' },
                            { item: 'Efficient image loading and caching strategies.', explanation: 'Images should be loaded asynchronously. They should be cached both in memory (for quick access) and on disk (for persistence). Resizing images to the display size before they are rendered can also save significant memory and improve performance.', question: 'Describe the high-level design of a two-layer image cache (memory and disk).' },
                            { item: 'Local and Push Notifications (APNs).', explanation: 'Local notifications are scheduled by the app itself. Push notifications are sent from a server via the Apple Push Notification service (APNs). Handling notifications involves requesting user permission and implementing delegate methods to respond when a notification is received.', question: 'What is a "silent" push notification and what is it commonly used for?' }
                        ]
                    },
                    {
                        id: 'tooling-security-testing', title: 'Security & Testing', durationHours: 7, suggestedWeek: 7, content: [
                            { item: 'App Security: Data encryption, Keychain usage, secure communication.', explanation: 'Sensitive data should be encrypted at rest. The Keychain is the appropriate place to store small, sensitive items like passwords or tokens. All network communication must use HTTPS.', question: 'What is the difference between storing an API key in `UserDefaults` versus the `Keychain`? Why is the Keychain more secure?' },
                            { item: 'Unit testing with XCTest and mocking dependencies.', explanation: 'Unit tests verify small, isolated pieces of code. To isolate the code under test, its dependencies (e.g., a network client) are often replaced with "mock" objects that simulate the real dependency\'s behavior in a predictable way.', question: 'What is Dependency Injection and how does it make code easier to test?' },
                            { item: 'UI testing with XCTest.', explanation: 'UI tests automate user interactions with your app\'s UI to verify that flows and visual elements work as expected. They are slower and more brittle than unit tests but are essential for validating the end-user experience.', question: 'How can you make your UI tests more robust and less likely to break when the UI changes? What role do `accessibilityIdentifier`s play?' }
                        ]
                    },
                    {
                        id: 'tooling-cicd-deps', title: 'Build & Dependency Management', durationHours: 4, suggestedWeek: 7, content: [
                            { item: 'CI/CD: Basic understanding of continuous integration and deployment pipelines.', explanation: 'CI/CD automates the process of building, testing, and deploying your app. A CI server (like Jenkins, GitHub Actions, or Bitrise) automatically builds the project and runs tests on every code push, ensuring new changes don\'t break the app.', question: 'What are the main benefits of having a CI/CD pipeline for an iOS project?' },
                            { item: 'Code Signing and Provisioning Profiles.', explanation: 'Code signing is how Apple verifies that an app was created by a known developer and has not been tampered with. Provisioning profiles link the app, the developer certificate, and the device IDs, allowing the app to be installed on specific devices for testing or distributed via the App Store.', question: 'What is the difference between a development provisioning profile and a distribution provisioning profile?' },
                            { item: 'Dependency Management: CocoaPods, Swift Package Manager (SPM), Carthage.', explanation: 'These tools automate the process of integrating third-party libraries into your project. CocoaPods is a long-standing, centralized manager. Carthage is a decentralized manager. SPM is Apple\'s official, integrated solution.', question: 'What are the main advantages of using Swift Package Manager over CocoaPods?' }
                        ]
                    }
                ]
            }
        ];


        const mainNav = document.getElementById('main-nav');
        const mainContent = document.getElementById('main-content');
        const charts = {};

        // Sidebar elements
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebar-toggle');
        const sidebarTextItems = document.querySelectorAll('.sidebar-text-item');
        let isSidebarExpanded = true; // Default to expanded

        function applySidebarState() {
            if (window.innerWidth < 768) { // Always collapse on small screens
                sidebar.classList.remove('md:w-80');
                sidebar.classList.add('w-full', 'h-auto');
                sidebarTextItems.forEach(el => el.classList.remove('hidden')); // Keep text for small screens
                sidebarToggle.classList.add('hidden'); // Hide toggle on small screens
                mainNav.querySelectorAll('.sidebar-link').forEach(link => {
                    link.classList.remove('justify-center', 'px-0');
                    link.classList.add('px-4');
                    const linkText = link.querySelector('.sidebar-text-item');
                    if(linkText) linkText.classList.remove('hidden');
                });
                return; // Exit as desktop logic doesn't apply
            }

            // Desktop / tablet logic
            if (isSidebarExpanded) {
                sidebar.classList.remove('md:w-16');
                sidebar.classList.add('md:w-80');
                sidebarTextItems.forEach(el => el.classList.remove('hidden'));
                sidebarToggle.innerHTML = '<span class="text-xl">‚ù∞</span>';
                sidebarToggle.classList.remove('hidden'); // Ensure toggle is visible on desktop
                mainNav.querySelectorAll('.sidebar-link').forEach(link => {
                    link.classList.remove('justify-center', 'px-0');
                    link.classList.add('px-4');
                    const linkText = link.querySelector('.sidebar-text-item');
                    if(linkText) linkText.classList.remove('hidden');
                });
            } else {
                sidebar.classList.remove('md:w-80');
                sidebar.classList.add('md:w-16');
                sidebarTextItems.forEach(el => el.classList.add('hidden'));
                sidebarToggle.innerHTML = '<span class="text-xl">‚ù±</span>';
                sidebarToggle.classList.remove('hidden'); // Ensure toggle is visible on desktop
                mainNav.querySelectorAll('.sidebar-link').forEach(link => {
                    link.classList.add('justify-center', 'px-0');
                    link.classList.remove('px-4');
                    const linkText = link.querySelector('.sidebar-text-item');
                    if(linkText) linkText.classList.add('hidden');
                });
            }
        }


        function toggleSidebar() {
            isSidebarExpanded = !isSidebarExpanded;
            localStorage.setItem('isSidebarExpanded', isSidebarExpanded);
            applySidebarState();
        }

        // Function to create checklist HTML
        function createChecklistHTML(itemsArray, subTopicIdPrefix) { // Changed subTopicContent to itemsArray
            let html = `<ul class="space-y-4 list-disc list-inside">`;
            // itemsArray is now expected to be an array directly
            itemsArray.forEach((item, index) => {
                const itemText = item.item;
                const explanation = item.explanation;
                const question = item.question;
                const itemId = `${subTopicIdPrefix}-${index}`; // Unique ID for the checklist item

                // Check if this item is marked as completed in localStorage
                const isChecked = allChecklistStatuses[subTopicIdPrefix] && allChecklistStatuses[subTopicIdPrefix][itemId] ? 'checked' : '';

                html += `
                    <li class="checklist-item flex flex-col items-start">
                        <div class="flex items-start w-full">
                            <input type="checkbox" id="${itemId}" class="mr-2 mt-1" ${isChecked}>
                            <label for="${itemId}" class="flex-1">${itemText}</label>
                            ${explanation ? `<button class="ml-2 px-3 py-1 info-toggle-btn" data-toggle="explanation" data-target="${itemId}-explanation">Explain</button>` : ''}
                            ${question ? `<button class="ml-2 px-3 py-1 info-toggle-btn" data-toggle="question" data-target="${itemId}-question">Practice Question</button>` : ''}
                        </div>
                        ${explanation ? `<div id="${itemId}-explanation" class="info-content w-full hidden"><strong>Explanation:</strong> ${explanation}</div>` : ''}
                        ${question ? `<div id="${itemId}-question" class="info-content w-full hidden"><strong>Practice Question:</strong> ${question}</div>` : ''}
                    </li>
                `;
            });
            html += `</ul>`;
            return html;
        }

        // Function to create and update Chart.js donut charts
        function createChart(canvasId, progress, textContent) { // Added textContent parameter for flexibility
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            // Destroy existing chart if it exists to prevent overlap
            if (charts[canvasId]) {
                charts[canvasId].destroy();
            }

            charts[canvasId] = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    datasets: [{
                        data: [progress, 100 - progress],
                        backgroundColor: ['#2a665c', '#E7E5E0'],
                        borderColor: ['#2a665c', '#E7E5E0'],
                        borderWidth: 1,
                        circumference: 360,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: '80%',
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }, // Disable tooltips for cleaner look
                        datalabels: { // Use Chart.js datalabels plugin if desired for showing percentage inside
                            display: false // Set to true and add datalabels plugin if needed
                        }
                    },
                    animation: {
                        duration: 500
                    }
                }
            });

            // Update associated text element if textContent is provided
            const progressTextElement = document.getElementById(`${canvasId}-text`);
            if (progressTextElement) {
                progressTextElement.textContent = `${Math.round(progress)}% Complete`;
            }
        }

        // Function to update progress text and chart for a given section (subtopic)
        function updateSubTopicProgress(subTopicId) {
            const subTopicPanel = document.getElementById(subTopicId);
            if (!subTopicPanel) return;
            const checkboxes = subTopicPanel.querySelectorAll('input[type="checkbox"]');
            const checked = subTopicPanel.querySelectorAll('input[type="checkbox"]:checked');
            const progress = checkboxes.length > 0 ? (checked.length / checkboxes.length) * 100 : 0;

            const progressTextElement = subTopicPanel.querySelector('.progress-text');
             if(progressTextElement){
                progressTextElement.textContent = `${Math.round(progress)}% Complete`;
             }

            createChart(`chart-${subTopicId}`, progress); // Update the subtopic's chart
        }

        // Function to calculate and return progress for a main topic
        function getTopicProgress(topicId) {
            const topic = studyData.find(t => t.id === topicId);
            if (!topic || topic.isStudyPlan) return 0;

            let totalItems = 0;
            let completedItems = 0;

            topic.subTopics.forEach(sub => {
                if (sub.content) {
                    totalItems += sub.content.length;
                    sub.content.forEach((item, index) => {
                        const itemId = `${sub.id}-${index}`;
                        if (allChecklistStatuses[sub.id] && allChecklistStatuses[sub.id][itemId]) {
                            completedItems++;
                        }
                    });
                }
            });
            return totalItems > 0 ? (completedItems / totalItems) * 100 : 0;
        }

        // Function to calculate and return overall progress
        function getOverallProgress() {
            let totalItems = 0;
            let completedItems = 0;

            studyData.forEach(topic => {
                if (!topic.isStudyPlan) {
                    topic.subTopics.forEach(sub => {
                        if (sub.content) {
                            totalItems += sub.content.length;
                            sub.content.forEach((item, index) => {
                                const itemId = `${sub.id}-${index}`;
                                if (allChecklistStatuses[sub.id] && allChecklistStatuses[sub.id][itemId]) {
                                    completedItems++;
                                }
                            });
                        }
                    });
                }
            });
            return totalItems > 0 ? (completedItems / totalItems) * 100 : 0;
        }

        // Function to update all charts (overall, topic, subtopic)
        function updateAllCharts() {
            // Update overall progress chart on study plan page
            const overallProgress = getOverallProgress();
            createChart('chart-overall-progress', overallProgress);
            const overallProgressText = document.getElementById('overall-progress-text');
            if (overallProgressText) {
                overallProgressText.textContent = `${Math.round(overallProgress)}% Complete`;
            }

            // Update each main topic's progress chart
            studyData.forEach(topic => {
                if (!topic.isStudyPlan) {
                    const topicProgress = getTopicProgress(topic.id);
                    createChart(`chart-main-topic-${topic.id}`, topicProgress);
                    const topicProgressText = document.getElementById(`main-topic-${topic.id}-progress-text`);
                    if (topicProgressText) {
                         topicProgressText.textContent = `${Math.round(topicProgress)}% Complete`;
                    }

                    // Also ensure all subtopic charts are updated
                    topic.subTopics.forEach(sub => {
                        updateSubTopicProgress(sub.id);
                    });
                }
            });
        }


        // Function to update the study status display for individual topics
        function updateTopicStatusDisplay(topicId) {
            const topicStatusDiv = document.getElementById(`topic-${topicId}-due-status`);
            if (!topicStatusDiv) return;

            if (!currentStudyStartDate) {
                topicStatusDiv.innerHTML = `<span class="text-gray-500 text-sm">Set a start date in the Study Plan to see your schedule.</span>`;
                return;
            }

            const topic = studyData.find(t => t.id === topicId);
            if (!topic || !topic.subTopics.length) {
                topicStatusDiv.innerHTML = `<span class="text-gray-500 text-sm">No specific week assigned for this topic.</span>`;
                return;
            }

            // Find the minimum and maximum scaledWeek for this topic's subtopics that are NOT completed
            const uncompletedSubTopicsInThisTopic = topic.subTopics.filter(sub => {
                if (!sub.content || sub.content.length === 0) return false; // Exclude subtopics with no content
                return sub.content.some((item, index) => {
                    const itemId = `${sub.id}-${index}`;
                    return !(allChecklistStatuses[sub.id] && allChecklistStatuses[sub.id][itemId]);
                });
            });

            const suggestedWeeks = uncompletedSubTopicsInThisTopic.map(sub => sub.scaledWeek).filter(week => week != null);


            if (suggestedWeeks.length === 0) { // All subtopics might be completed
                topicStatusDiv.innerHTML = `<span class="text-green-600 text-sm font-medium">All subtopics completed for this topic! üéâ</span>`;
                return;
            }

            const minWeek = Math.min(...suggestedWeeks);
            const maxWeek = Math.max(...suggestedWeeks);

            const topicStartWeekData = globalStudyPlanDates[minWeek];
            const topicEndWeekData = globalStudyPlanDates[maxWeek];

            if (!topicStartWeekData || !topicEndWeekData) {
                topicStatusDiv.innerHTML = `<span class="text-gray-500 text-sm">Study plan not fully generated for this topic's weeks.</span>`;
                return;
            }

            const topicStartDate = topicStartWeekData.startDate;
            const topicEndDate = topicEndWeekData.endDate;
            const today = new Date();
            today.setHours(0, 0, 0, 0); // Normalize today's date

            let statusText = '';
            let statusColorClass = 'text-gray-700';

            const options = { year: 'numeric', month: 'short', day: 'numeric' };
            const formattedStartDate = topicStartDate.toLocaleDateString('en-US', options);
            const formattedEndDate = topicEndDate.toLocaleDateString('en-US', options);

            if (today < topicStartDate) {
                statusText = `Upcoming: Starts Week ${minWeek} (${formattedStartDate})`;
                statusColorClass = 'text-blue-600'; // Blue for upcoming
            } else if (today >= topicStartDate && today <= topicEndDate) {
                statusText = `In Progress: Week ${minWeek}-${maxWeek} (Due by ${formattedEndDate})`;
                statusColorClass = 'text-green-600'; // Green for on track
            } else {
                statusText = `Past Due: Was due by ${formattedEndDate}`;
                statusColorClass = 'text-red-600'; // Red for past due
            }

            topicStatusDiv.innerHTML = `<p class="text-sm font-medium ${statusColorClass}">${statusText}</p>`;
        }


        // Function to handle main topic selection, and optionally subtopic tab
        function selectMainTopic(topicId, subTopicId = null) {
            // Clear active state from all sidebar links
            document.querySelectorAll('.sidebar-link').forEach(link => {
                if (link) link.classList.remove('active');
            });
            // Set active state for the current sidebar link
            const activeLink = document.querySelector(`a[href="#${topicId}"]`);
            if (activeLink) {
                activeLink.classList.add('active');
            }

            // Hide all content panels
            document.querySelectorAll('.content-panel').forEach(panel => {
                if (panel) panel.classList.remove('active');
            });
            // Show the selected content panel
            const activePanel = document.getElementById(topicId);
            if (activePanel) {
                activePanel.classList.add('active');

                // If it's not the study plan, activate the correct subtopic tab
                const topicData = studyData.find(t => t.id === topicId);
                if (topicData && !topicData.isStudyPlan && topicData.subTopics.length > 0) {
                    // Use requestAnimationFrame to ensure DOM is ready for tab activation
                    requestAnimationFrame(() => {
                        const targetSubTopicId = subTopicId || topicData.subTopics[0].id;
                        selectSubTopic(topicId, targetSubTopicId);
                    });
                }
            }

            // Update topic status display when a topic is selected (if not the study plan)
            if (!studyData.find(t => t.id === topicId).isStudyPlan) {
                updateTopicStatusDisplay(topicId);
            }
        }

        // Function to handle sub-topic tab selection
        function selectSubTopic(mainTopicId, subTopicId) {
            const mainPanel = document.getElementById(mainTopicId);
            if (!mainPanel) return;

            const tabLinks = mainPanel.querySelectorAll('.tab-link');
            const subContentPanels = mainPanel.querySelectorAll('.sub-content-panel');

            // Deactivate all tabs and sub-content panels within the main topic
            tabLinks.forEach(link => link.classList.remove('active'));
            subContentPanels.forEach(panel => panel.classList.remove('active'));

            // Activate the targeted tab and its corresponding content panel
            const activeTab = mainPanel.querySelector(`button[data-tab="${subTopicId}"]`);
            const activeSubPanel = mainPanel.querySelector(`#${subTopicId}`);

            if (activeTab) {
                activeTab.classList.add('active');
            } else {
                // Fallback: if the specific subTopicId button isn't found, activate the first one
                if (tabLinks.length > 0) tabLinks[0].classList.add('active');
            }

            if (activeSubPanel) {
                activeSubPanel.classList.add('active');
            } else {
                // Fallback: if the specific sub-content panel isn't found, activate the first one
                if (subContentPanels.length > 0) subContentPanels[0].classList.add('active');
            }
        }

        // Calculate originalMaxWeeks dynamically from the studyData
        let originalMaxWeeksCalculated = 0;
        studyData.forEach(topic => {
            if (!topic.isStudyPlan) {
                topic.subTopics.forEach(sub => {
                    if (sub.suggestedWeek && sub.suggestedWeek > originalMaxWeeksCalculated) {
                        originalMaxWeeksCalculated = sub.suggestedWeek;
                    }
                });
            }
        });
        const ORIGINAL_MAX_WEEKS = originalMaxWeeksCalculated || 1; // Avoid division by zero
        const HIGH_INTENSITY_THRESHOLD_HOURS = 25; // Define a threshold for high weekly study hours


        // Function to generate and display the study plan
        function generateStudyPlan() {
            const startDateInput = document.getElementById('start-date-input');
            const inputDate = startDateInput.value;
            if (!inputDate) {
                document.getElementById('study-plan-output').innerHTML = '<p class="text-red-600">Please select a valid start date.</p>';
                return;
            }
            const startDate = new Date(inputDate);
            currentStudyStartDate = startDate; // Set global start date
            localStorage.setItem('studyStartDate', inputDate); // Persist start date in local storage

            const studyPlanContainer = document.getElementById('study-plan-output');
            studyPlanContainer.innerHTML = ''; // Clear previous plan

            const numWeeksFromSlider = parseInt(document.getElementById('num-weeks-slider').value, 10);

            // Reset global study plan dates and initialize for all weeks
            globalStudyPlanDates = {};
            for (let i = 1; i <= numWeeksFromSlider; i++) {
                const weekStartDate = new Date(startDate);
                weekStartDate.setDate(startDate.getDate() + (i - 1) * 7);
                const weekEndDate = new Date(weekStartDate);
                weekEndDate.setDate(weekStartDate.getDate() + 6);
                globalStudyPlanDates[i] = { startDate: weekStartDate, endDate: weekEndDate, topics: [] };
            }

            let totalSyllabusHours = 0; // Total hours in the syllabus regardless of completion
            let completedHours = 0;
            let uncompletedSubTopics = [];

            // First pass: Calculate total hours and identify uncompleted subtopics
            studyData.forEach(topic => {
                if (!topic.isStudyPlan) {
                    topic.subTopics.forEach(sub => {
                        totalSyllabusHours += sub.durationHours; // Sum up all hours for total calculation

                        // Determine if subtopic is fully completed
                        let isSubTopicCompleted = true;
                        if (sub.content && sub.content.length > 0) { // Only check completion if there are items
                            sub.content.forEach((item, index) => {
                                const itemId = `${sub.id}-${index}`;
                                if (!(allChecklistStatuses[sub.id] && allChecklistStatuses[sub.id][itemId])) {
                                    isSubTopicCompleted = false; // Found an uncompleted item
                                }
                            });
                        } else { // If a subtopic has no content, consider it completed for hours calculation
                            isSubTopicCompleted = true; 
                        }

                        if (isSubTopicCompleted) {
                            completedHours += sub.durationHours;
                        } else {
                            uncompletedSubTopics.push(sub);
                        }
                    });
                }
            });

            const remainingHours = totalSyllabusHours - completedHours;

            // Determine the maximum suggestedWeek among *uncompleted* topics to use for scaling
            let uncompletedOriginalMaxWeeks = 0;
            uncompletedSubTopics.forEach(sub => {
                if (sub.suggestedWeek && sub.suggestedWeek > uncompletedOriginalMaxWeeks) {
                    uncompletedOriginalMaxWeeks = sub.suggestedWeek;
                }
            });

            // If all original topics were completed, or if there are no uncompleted topics,
            // use the full original duration for scaling to avoid division by zero or weird scaling.
            const effectiveOriginalMaxWeeks = uncompletedOriginalMaxWeeks === 0 ? ORIGINAL_MAX_WEEKS : uncompletedOriginalMaxWeeks;

            // Second pass: Assign scaled weeks to uncompleted topics and populate globalStudyPlanDates
            studyData.forEach(topic => {
                if (!topic.isStudyPlan) {
                    topic.subTopics.forEach(sub => {
                        // Re-check completion status for this sub to decide if it's added to the plan
                        let isSubTopicCompleted = true;
                        if (sub.content && sub.content.length > 0) {
                            sub.content.forEach((item, index) => {
                                const itemId = `${sub.id}-${index}`;
                                if (!(allChecklistStatuses[sub.id] && allChecklistStatuses[sub.id][itemId])) {
                                    isSubTopicCompleted = false;
                                }
                            });
                        } else {
                            isSubTopicCompleted = true;
                        }

                        if (isSubTopicCompleted) {
                            sub.scaledWeek = null; // Mark as completed, no week assignment needed for planning
                        } else {
                            if (sub.suggestedWeek) {
                                let newWeek = Math.ceil(sub.suggestedWeek * (numWeeksFromSlider / effectiveOriginalMaxWeeks));
                                newWeek = Math.max(1, Math.min(numWeeksFromSlider, newWeek)); // Ensure it's within bounds
                                sub.scaledWeek = newWeek; // Store the scaled week for future reference and status update

                                // Push to the pre-initialized week's topics array
                                if (globalStudyPlanDates[sub.scaledWeek]) {
                                    globalStudyPlanDates[sub.scaledWeek].topics.push({
                                        mainTopic: topic.cleanTitle || topic.title,
                                        mainTopicId: topic.id, // Store main topic ID for linking
                                        subTopic: sub.title,
                                        subTopicId: sub.id, // Store subtopic ID for direct linking
                                        duration: sub.durationHours
                                    });
                                }
                            }
                        }
                    });
                }
            });

            const avgHoursPerWeek = remainingHours > 0 && numWeeksFromSlider > 0 ? (remainingHours / numWeeksFromSlider).toFixed(1) : 0;

            let overviewHTML = `
                <div class="bg-[#ECEAE5] p-4 rounded-lg shadow-sm mb-6 flex flex-col md:flex-row items-center justify-between">
                    <div class="flex-1">
                        <h3 class="text-xl font-semibold text-[#2a665c] mb-2">Plan Overview</h3>
                        <p class="text-gray-700">Estimated Total Syllabus Hours: <span class="font-bold">${totalSyllabusHours} hours</span>.</p>
                        <p class="text-gray-700">Completed Hours: <span class="font-bold">${completedHours} hours</span>.</p>
                        <p class="text-gray-700">Remaining Hours: <span class="font-bold">${remainingHours} hours</span>.</p>
                        <p class="text-gray-700">Study Duration: <span class="font-bold">${numWeeksFromSlider} weeks</span>.</p>
                        <p class="text-gray-700">Average Weekly Effort for Remaining Work: <span class="font-bold">${avgHoursPerWeek} hours/week</span> (approx).</p>
                        ${parseFloat(avgHoursPerWeek) > HIGH_INTENSITY_THRESHOLD_HOURS ? `
                            <p class="text-red-600 mt-4 font-semibold">‚ö†Ô∏è Warning: This plan is highly intensive! (${avgHoursPerWeek} hours/week). Consider increasing the study duration or strategically reducing the scope of topics to maintain a sustainable pace.</p>
                        ` : ''}
                    </div>
                    <div class="flex flex-col items-center ml-0 md:ml-8 mt-4 md:mt-0">
                        <div class="chart-container">
                            <canvas id="chart-overall-progress"></canvas>
                        </div>
                        <span id="overall-progress-text" class="text-lg font-medium text-gray-600 mt-2">0% Complete</span>
                    </div>
                </div>
            `;
            studyPlanContainer.innerHTML += overviewHTML;


            for (let week = 1; week <= numWeeksFromSlider; week++) { // Iterate through ALL weeks
                const weekData = globalStudyPlanDates[week]; // This will now always exist

                const options = { year: 'numeric', month: 'short', day: 'numeric' };
                let weekDates = '';
                if (weekData) { // Check if weekData exists (it should now always, but safe guard)
                    weekDates = `${weekData.startDate.toLocaleDateString('en-US', options)} - ${weekData.endDate.toLocaleDateString('en-US', options)}`;
                }

                let weekTotalHours = 0;
                let topicsListHTML = '';

                if (weekData && weekData.topics.length > 0) {
                    weekData.topics.forEach(item => {
                        topicsListHTML += `<li class="ml-4 text-gray-700"><a href="#${item.mainTopicId}" data-topic-id="${item.mainTopicId}" data-subtopic-id="${item.subTopicId}" class="study-plan-topic-link">${item.mainTopic}: <strong>${item.subTopic}</strong></a> (${item.duration} hours)</li>`;
                        weekTotalHours += item.duration;
                    });
                } else {
                    topicsListHTML = `<li class="ml-4 text-gray-500">No topics scheduled for this week.</li>`;
                }


                const weekHTML = `
                    <div class="bg-white p-6 rounded-lg shadow-sm mb-4 border-l-4 border-[#2a665c]">
                        <h3 class="text-xl font-semibold text-gray-800 mb-2">Week ${week} <span class="text-base text-gray-500 font-normal">(${weekDates})</span></h3>
                        <p class="text-gray-600 mb-4">Total estimated for this week: <span class="font-bold">${weekTotalHours} hours</span></p>
                        <ul class="list-disc text-sm space-y-2">
                            ${topicsListHTML}
                        </ul>
                    </div>
                `;
                studyPlanContainer.innerHTML += weekHTML;
            }

            // After generating the plan, update all charts and topic statuses
            updateAllCharts();
             studyData.forEach(topic => {
                if (!topic.isStudyPlan) {
                    updateTopicStatusDisplay(topic.id);
                }
            });
        }


        // Event listener for when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', function () {
            // Restore sidebar state
            const savedSidebarState = localStorage.getItem('isSidebarExpanded');
            if (savedSidebarState !== null) {
                isSidebarExpanded = JSON.parse(savedSidebarState);
            }
            applySidebarState(); // Apply initial state on load

            // Attach toggle listener
            sidebarToggle.addEventListener('click', toggleSidebar);

            // Load saved checklist states
            const savedChecklistStatus = localStorage.getItem('checklistStatus');
            if (savedChecklistStatus) {
                allChecklistStatuses = JSON.parse(savedChecklistStatus);
            }

            // Dynamically create main content panels
            studyData.forEach((topic) => {
                const contentPanel = document.createElement('div');
                contentPanel.id = topic.id;
                contentPanel.className = 'content-panel';

                let innerHTML = `
                    <h2 class="text-3xl font-bold text-gray-800 mb-4">${topic.cleanTitle || topic.title}</h2>
                    <p class="text-gray-700 mb-6">${topic.description}</p>
                `;

                // Add study plan status display and main topic chart for non-study plan pages
                if (!topic.isStudyPlan) {
                    innerHTML += `
                        <div class="mb-6 p-4 rounded-lg bg-white shadow-sm border border-gray-200 flex flex-col md:flex-row items-center justify-between">
                            <div id="topic-${topic.id}-due-status" class="flex-1 mb-4 md:mb-0">
                                <span class="text-gray-500 text-sm">Set a start date in the Study Plan to see your schedule.</span>
                            </div>
                            <div class="flex flex-col items-center ml-0 md:ml-8">
                                <div class="chart-container">
                                    <canvas id="chart-main-topic-${topic.id}"></canvas>
                                </div>
                                <span id="main-topic-${topic.id}-progress-text" class="text-lg font-medium text-gray-600 mt-2">0% Complete</span>
                            </div>
                        </div>
                    `;
                }

                if (topic.isStudyPlan) {
                    // Specific content for the Study Plan page
                    innerHTML += `
                        <div class="bg-white p-6 rounded-lg shadow-sm mb-6">
                            <h3 class="text-xl font-semibold text-gray-800 mb-4">Set Your Study Plan</h3>
                            <div class="flex flex-col sm:flex-row items-center space-y-4 sm:space-y-0 sm:space-x-4">
                                <input type="date" id="start-date-input" class="p-2 border border-gray-300 rounded-md text-gray-800">
                                <div class="flex-grow">
                                    <label for="num-weeks-slider" class="block text-gray-700 text-sm font-bold mb-2">
                                        Study Duration: <span id="num-weeks-value">8</span> weeks
                                    </label>
                                    <input type="range" id="num-weeks-slider" min="2" max="12" value="8" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                                </div>
                                <button id="generate-plan-button" class="px-6 py-2 bg-[#2a665c] text-white font-semibold rounded-md shadow hover:bg-opacity-90 transition duration-200">Generate Plan</button>
                            </div>
                        </div>
                        <div id="study-plan-output">
                            <p class="text-gray-600">Enter a start date and click "Generate Plan" to see your personalized study schedule.</p>
                        </div>
                    `;
                } else {
                    // Tab navigation for sub-topics
                    innerHTML += `
                        <div class="flex flex-wrap border-b border-gray-300 mb-6 overflow-x-auto">
                            ${topic.subTopics.map((sub) => `
                                <button class="tab-link px-4 py-2 text-gray-600 hover:text-[#2a665c] border-b-2 border-transparent hover:border-[#2a665c] transition duration-200 text-sm md:text-base" data-tab="${sub.id}">${sub.title}</button>
                            `).join('')}
                        </div>
                    `;
                    // Sub-content panels for each sub-topic
                    topic.subTopics.forEach(sub => {
                        innerHTML += `
                            <div id="${sub.id}" class="sub-content-panel bg-white p-6 rounded-lg shadow-sm mb-6">
                                <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-4">
                                    <h4 class="text-xl font-semibold text-gray-800 mb-2 md:mb-0">${sub.title}</h4>
                                    <div class="flex items-center space-x-4">
                                        <span class="text-lg font-medium text-gray-600 progress-text">0% Complete</span>
                                        <div class="chart-container" style="max-width: 100px; height: 100px;">
                                            <canvas id="chart-${sub.id}"></canvas> <!-- Chart per sub-topic -->
                                        </div>
                                    </div>
                                </div>
                                <div class="border-t border-gray-200 pt-4 mt-4">
                                    ${createChecklistHTML(sub.content, sub.id)}
                                </div>
                            </div>
                        `;
                    });
                }
                contentPanel.innerHTML = innerHTML;
                mainContent.appendChild(contentPanel);
            });

            // Populate sidebar navigation
            studyData.forEach(topic => {
                const navLink = document.createElement('a');
                navLink.href = `#${topic.id}`;
                navLink.className = 'block sidebar-link font-medium text-gray-700 py-2 px-4 rounded-md flex items-center space-x-2';
                navLink.addEventListener('click', (e) => {
                    e.preventDefault();
                    selectMainTopic(topic.id); // Navigate to main topic
                });

                const iconSpan = document.createElement('span');
                // Use calendar for Study Plan, Roman numeral for others
                if (topic.id === 'study-plan') {
                    iconSpan.textContent = 'üóìÔ∏è'; // Calendar emoji for study plan
                } else {
                    // Extract Roman numeral from 'I. Topic Name'
                    const match = topic.title.match(/^([IVXLCDM]+\.)/);
                    iconSpan.textContent = match ? match[1] : '‚Ä¢'; // Get the Roman numeral part or a bullet
                }
                iconSpan.className = 'font-bold text-lg flex-shrink-0';

                const textSpan = document.createElement('span');
                // Use cleanTitle if available, and remove the numeral for display
                textSpan.textContent = (topic.cleanTitle || topic.title).replace(/^[IVXLCDM]+\.\s*/, '');
                textSpan.className = 'sidebar-text-item flex-grow';

                navLink.appendChild(iconSpan);
                navLink.appendChild(textSpan);

                mainNav.appendChild(navLink);
            });

            // Re-apply sidebar state after nav items are created, to hide text in nav links if collapsed
            applySidebarState();

            // Check for saved start date on initial load
            const savedStartDate = localStorage.getItem('studyStartDate');
            if (savedStartDate) {
                const startDateInput = document.getElementById('start-date-input');
                if (startDateInput) {
                    startDateInput.value = savedStartDate;
                    currentStudyStartDate = new Date(savedStartDate);
                    generateStudyPlan(); // Re-generate plan on load if date exists
                }
            } else {
                 // If no saved date, just initialize all charts (without plan data)
                 updateAllCharts();
            }


            // Set the study plan page as the default active page
            selectMainTopic(studyData[0].id);


            // Event listener for checkbox changes to update progress
            document.body.addEventListener('change', (e) => {
                if (e.target.matches('input[type="checkbox"]')) {
                    const checkboxId = e.target.id;
                    const subTopicPanel = e.target.closest('.sub-content-panel');
                    const subTopicPanelId = subTopicPanel ? subTopicPanel.id : null;

                    if (subTopicPanelId) {
                         if (!allChecklistStatuses[subTopicPanelId]) {
                            allChecklistStatuses[subTopicPanelId] = {};
                        }
                        allChecklistStatuses[subTopicPanelId][checkboxId] = e.target.checked;
                        localStorage.setItem('checklistStatus', JSON.stringify(allChecklistStatuses));
                        
                        // Regenerate plan to reflect progress in the schedule, this also calls updateAllCharts
                         if(currentStudyStartDate) {
                           generateStudyPlan();
                         } else {
                           updateAllCharts();
                         }
                    }
                }
            });

            // Event listener for slider to update value display
             const slider = document.getElementById('num-weeks-slider');
             if(slider){
                slider.addEventListener('input', function() {
                    document.getElementById('num-weeks-value').textContent = this.value;
                });
             }


            // Event listener for button clicks (generate plan, tab switching, info toggles, study plan topic links)
            document.body.addEventListener('click', async (e) => {
                if (e.target.matches('.tab-link')) {
                    const mainTopicId = e.target.closest('.content-panel').id;
                    const subTopicId = e.target.dataset.tab;
                    selectSubTopic(mainTopicId, subTopicId);
                } else if (e.target.id === 'generate-plan-button') {
                    generateStudyPlan();
                } else if (e.target.matches('.info-toggle-btn')) {
                    const targetId = e.target.dataset.target;
                    const infoDiv = document.getElementById(targetId);
                    if (infoDiv) {
                        infoDiv.classList.toggle('hidden');
                    }
                } else if (e.target.closest('.study-plan-topic-link')) { // Use closest() to find the anchor tag
                    e.preventDefault(); // Prevent default link behavior
                    const linkElement = e.target.closest('.study-plan-topic-link');
                    const topicId = linkElement.dataset.topicId;
                    const subTopicId = linkElement.dataset.subtopicId;
                    // Navigate to the main topic, and then activate the subtopic
                    selectMainTopic(topicId, subTopicId);
                }
            });
        });
    </script>
</body>
</html>
